<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> (译) Google Kotlin CodeStyle · Averson</title><meta name="description" content="(译) Google Kotlin CodeStyle - Averson"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="Averson"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/aversoncoder" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">(译) Google Kotlin CodeStyle</h1><div class="post-info">2017年11月4日</div><div class="post-content"><p>Google 官方 Kotlin 编码风格翻译</p>
<a id="more"></a>
<h2 id="源文件"><a href="#源文件" class="headerlink" title="源文件"></a>源文件</h2><p>所有源文件编码必须是 <code>UTF-8</code>。</p>
<h4 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h4><p>如果源文件只包含一个顶级类（Top-level），文件名应该命名为大写小敏感和 <code>.kt</code> 拓展名。其他情况如果源文件包含多个顶级声明，则选择一个描述文件内容的名称，使用驼峰命名法，并附上名称和 <code>.kt</code> 拓展名。</p>
<blockquote>
<p>Top-level 解释请参考该<a href="https://blog.jetbrains.com/kotlin/2015/06/improving-java-interop-top-level-functions-and-properties/" target="_blank" rel="external">链接</a></p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 单一顶级类</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123; &#125;</div><div class="line"></div><div class="line"><span class="comment">// Bar.kt </span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> </span>&#123; &#125;</div><div class="line"><span class="function"><span class="keyword">fun</span> Runnabel.<span class="title">toBar</span><span class="params">()</span></span> : Bar = <span class="comment">// ...</span></div><div class="line"></div><div class="line"><span class="comment">// Map.kt -&gt; 描述文件内容的命名</span></div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T, O&gt;</span> Set<span class="type">&lt;T&gt;</span>.<span class="title">map</span><span class="params">(func: (<span class="type">T</span>)</span></span> -&gt; O): List&lt;O&gt; = <span class="comment">// …</span></div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T, O&gt;</span> List<span class="type">&lt;T&gt;</span>.<span class="title">map</span><span class="params">(func: (<span class="type">T</span>)</span></span> -&gt; O): List&lt;O&gt; = <span class="comment">// …</span></div></pre></td></tr></table></figure>
<h4 id="特殊编码"><a href="#特殊编码" class="headerlink" title="特殊编码"></a>特殊编码</h4><h4 id="空格"><a href="#空格" class="headerlink" title="空格"></a>空格</h4><p>除了换行，它是 <strong>ASCII 水平方向字符 (0x20) </strong> 唯一能出现在源文件中的空格。</p>
<blockquote>
<p>0x20 表示空格</p>
</blockquote>
<p>这意味着：</p>
<ul>
<li>所有其他空格字符在字符串和字符源文本中均被转义</li>
<li>制表符<strong>不</strong>用于缩进</li>
</ul>
<blockquote>
<p>源文本（literal），是指程序源代码中用来表示固定的值的符号序列。例如在大多数语言中，引号包围的字符序列即为字符串源文本（string literal），表示一个特定的字符串值。</p>
</blockquote>
<h4 id="特殊的转义序列"><a href="#特殊的转义序列" class="headerlink" title="特殊的转义序列"></a>特殊的转义序列</h4><p>对于任何具有特殊转义的字符（\b、\n、\r、\t、\’、\ 和 \$）使用的是对应的 <code>Unicode</code> 编码（例如：Line Feed : \n = u000a）转义。</p>
<h4 id="Non-ASCII-字符"><a href="#Non-ASCII-字符" class="headerlink" title="Non-ASCII 字符"></a>Non-ASCII 字符</h4><p>对于剩下的 <code>Non-ASCII</code> 字符，要么使用实际的 <code>Unicode</code> 字符（例如：∞），要么使用等效的 <code>Unicode</code> 转义（如：\u221e）。这个选择只取决于代码易读和理解。对于任何位置的可打印的字符，都不建议使用 <code>Unicode</code> 转义，尤其在字符串源文本和注释。</p>
<table>
<thead>
<tr>
<th>例子</th>
<th>建议</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>val unitAbbrev = &quot;μs&quot;</code></td>
<td>最好的：即使没有评论，也非常清楚</td>
</tr>
<tr>
<td><code>val unitAbbrev = &quot;\u03bcs&quot; // μs&quot;</code></td>
<td>较差的：没有理由在一个可打印字符字符中使用转义字符表示</td>
</tr>
<tr>
<td><code>val unitAbbrev = &quot;\u03bcs&quot;</code></td>
<td>较差的：代码阅读者不知道这是一个什么概念</td>
</tr>
<tr>
<td><code>return &quot;\ufeff&quot; + content</code></td>
<td>良好的：对不可打印字符使用转义，必要时可以进行注释。</td>
</tr>
</tbody>
</table>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>一个 <code>.kt</code> 文件由以下组成：</p>
<ol>
<li>版权和许可证(可选)</li>
<li>File-Level 注解</li>
<li>包名声明</li>
<li>导包声明</li>
<li>Top-level 声明</li>
</ol>
<p>每个部分均用换行来分隔。</p>
<h4 id="版权-许可证"><a href="#版权-许可证" class="headerlink" title="版权 / 许可证"></a>版权 / 许可证</h4><p>如果文件中包含版权或许可证，则应将其放在多行注释的最上面。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * Copyright 2017 Google, Inc.</div><div class="line"> *</div><div class="line"> * ...</div><div class="line"> */</div></pre></td></tr></table></figure>
<p>不要使用 <a href="https://kotlinlang.org/docs/reference/kotlin-doc.html" target="_blank" rel="external">KDoc-style</a> 或者单行注释。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Copyright 2017 Google, Inc.</div><div class="line"> *</div><div class="line"> * ...</div><div class="line"> */</div></pre></td></tr></table></figure>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Copyright 2017 Google, Inc.</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// ...</span></div></pre></td></tr></table></figure>
<h4 id="File-Level-注解"><a href="#File-Level-注解" class="headerlink" title="File-Level 注解"></a>File-Level 注解</h4><p>如果使用 <code>kotlin</code> 的 <code>File-Level</code> 注解请放在头部和包名声明之间。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> *  Copyright 2017 Google Inc.</div><div class="line"> */</div><div class="line"></div><div class="line"><span class="meta">@file:JvmName</span>(<span class="string">"ViewUtils"</span>)</div><div class="line"></div><div class="line"><span class="keyword">package</span> domain.util</div></pre></td></tr></table></figure>
<h4 id="包名声明"><a href="#包名声明" class="headerlink" title="包名声明"></a>包名声明</h4><p>包名声明不受行列限制并且 使用 <code>line-wrap</code> 模式。</p>
<blockquote>
<p>line-wrap 参考<a href="https://zh.wikipedia.org/wiki/%E8%87%AA%E5%8A%A8%E6%8D%A2%E8%A1%8C" target="_blank" rel="external">维基百科定义</a></p>
</blockquote>
<h4 id="导包声明"><a href="#导包声明" class="headerlink" title="导包声明"></a>导包声明</h4><p>类、函数和属性的导入语句组合在一个单独列表中，并按 <code>ASCII</code> 排序。</p>
<p><strong>不允许</strong>使用通配符导入。</p>
<p>和”包名声明”一样，导包声明不受行列限制并且 使用 <code>line-wrap</code> 模式。</p>
<h4 id="Top-level-声明"><a href="#Top-level-声明" class="headerlink" title="Top-level 声明"></a>Top-level 声明</h4><p>一个 <code>.kt</code> 文件可以在顶层声明一个或多个类型、函数、属性或类型别名。</p>
<p>文件中内容应该围绕一个主题。</p>
<p>比如只有一个公开类型（public）或一组拓展函数，对于多个接收者都应该执行同样的操作。</p>
<p>比如（<code>AreaMaths.kt</code>）：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> Circle.<span class="title">area</span><span class="params">()</span></span> : <span class="built_in">Double</span> &#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fun</span> Rectangle.<span class="title">area</span><span class="params">()</span></span> : <span class="built_in">Double</span> &#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>不相关的声明应该分离开来放到自己的文件中，并且在一个文件内公开声明应该最小化尽可能的保持内聚。</p>
<p>没有文件内容的数量和排序限制。</p>
<p>源文件一般是从上至下阅读，所以尽可能按这个顺序反应出相关重要的内容。因此不同的文件可能会选择不同的排序。比如说，一个文件可能包含 100 个属性，10 个函数，1 个类。最重要的一点，每个类应该以某种逻辑去排序它的成员，维护者应该要能解释这种排序逻辑。再如：新函数不应该添加在类的末尾，因为这样是日期排序，这不是一个逻辑排序。</p>
<h4 id="成员变量排序"><a href="#成员变量排序" class="headerlink" title="成员变量排序"></a>成员变量排序</h4><p>类成员变量的排序和 Top-level 声明一致</p>
<h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><h4 id="大括号"><a href="#大括号" class="headerlink" title="大括号"></a>大括号</h4><p><code>when</code> 分支和不具有 <code>if/else</code> 的分支且适用于单行的语句不需要大括号。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (string.isEmpty()) <span class="keyword">return</span></div><div class="line"></div><div class="line"><span class="keyword">when</span>(value) &#123;</div><div class="line">    () -&gt; <span class="keyword">return</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其他情况都需要大括号，比如说 <code>if</code>、<code>for</code>、<code>when</code>、<code>do</code> 和 <code>while</code>。即使语句体是空语句或者只有一句也需要大括号。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (string.isEmpty()) </div><div class="line">    <span class="keyword">return</span> <span class="comment">// WRONG!</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> (string.isEmpty()) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="comment">// OKay</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="非空块"><a href="#非空块" class="headerlink" title="非空块"></a>非空块</h4><p>对于非空块和块状结构，大括号遵循 Kernighan（K） 和 Ritchie（R） 风格 (<a href="http://www.codinghorror.com/blog/2012/07/new-programming-jargon.html" target="_blank" rel="external">Egyptian brackets</a>)：</p>
<ul>
<li>左大括号前不换行</li>
<li>左大括号后换行</li>
<li>右大括号前换行</li>
<li>如果右大括号是一个语句、函数体或类的终止，则右大括号后换行; 否则不换行。例如，如果右大括号后面是 else 或逗号，则不换行。</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">return</span> Runnable &#123;</div><div class="line">    <span class="keyword">while</span> (condition()) &#123;</div><div class="line">        foo()</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">return</span> <span class="keyword">object</span> : MyClass() &#123;</div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="keyword">if</span> (condition()) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                something()</div><div class="line">            &#125; <span class="keyword">catch</span> (e: ProblemException) &#123;</div><div class="line">                recover()</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (otherCondition()) &#123;</div><div class="line">            somethingElse()</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            lastThing()</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>后续给出枚举类的一些例外。</p>
<h4 id="空块"><a href="#空块" class="headerlink" title="空块"></a>空块</h4><p>空语块或类似空语块的必须是 K&amp;R 风格</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">    doSomething()</div><div class="line">&#125; <span class="keyword">catch</span> (e: Exception) &#123;&#125; <span class="comment">// WRONG!!</span></div><div class="line"></div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">    doSomething()</div><div class="line">&#125; <span class="keyword">catch</span> (e: Exception) &#123;</div><div class="line">&#125; <span class="comment">// OKay</span></div></pre></td></tr></table></figure>
<h4 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h4><p>只有在单行能够完成整个表达式的 <code>if/else</code> 语句才适用省略大括号。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> value = <span class="keyword">if</span> (string.isEmpty()) <span class="number">0</span> <span class="keyword">else</span> <span class="number">1</span> <span class="comment">// OKay</span></div><div class="line"></div><div class="line"><span class="keyword">val</span> value = <span class="keyword">if</span> (string.isEmpty())  <span class="comment">// WRONG!!</span></div><div class="line">                <span class="number">0</span></div><div class="line">            <span class="keyword">else</span></div><div class="line">                <span class="number">1</span></div><div class="line"></div><div class="line"><span class="keyword">val</span> value = <span class="keyword">if</span> (string.isEmpty()) &#123; <span class="comment">// OKay</span></div><div class="line">    <span class="number">0</span></div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="number">1</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="缩进"><a href="#缩进" class="headerlink" title="缩进"></a>缩进</h4><p>每当开始一个新的块，缩进增加 4 个空格。</p>
<h4 id="每行一个语句"><a href="#每行一个语句" class="headerlink" title="每行一个语句"></a>每行一个语句</h4><p>每个语句后面都有一个换行符。不使用分号。</p>
<h4 id="自动换行"><a href="#自动换行" class="headerlink" title="自动换行"></a>自动换行</h4><p>一般情况下，一行长代码为了避免超出列限制(100个字符)而被分为多行，我们称之为自动换行(line-wrapping)。除了以下指出的情况，任何超出这些限制的必须按照说明换行。</p>
<ul>
<li>不可能遵循列限制的行(例如，KDoc中的一个长URL)</li>
<li>包和导入语句</li>
<li>在注释中可以剪切并粘贴到 shell 中的命令行。</li>
</ul>
<h4 id="从哪里断开"><a href="#从哪里断开" class="headerlink" title="从哪里断开"></a>从哪里断开</h4><p>自动换行的基本准则是：更倾向于在<strong>更高的语法级别</strong>处断开。</p>
<ol>
<li>如果在非赋值运算符处断开，那么在该符号前断开( +，它将位于下一行)。这条规则也适用以下类操作符语法：<ul>
<li>点分隔符(.)</li>
<li>双冒号(::)</li>
</ul>
</li>
<li>当赋值运算符在一行断开，符号后面会出现断开。</li>
<li>一个方法或者构造函数的参数名依然在左括号后面</li>
<li>逗号(,)与其前面的内容留在同一行。</li>
<li>lambda 的 -&gt; 符号和参数列表在同一行</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> longString = <span class="string">"some long text"</span></div><div class="line">                  + <span class="string">"some more long text"</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">longNameFunc</span><span class="params">(param1: <span class="type">string</span>, param2: <span class="type">string</span></span></span></div><div class="line">                 <span class="type">param3</span>: <span class="type">string</span>, param4: <span class="type">string</span>) &#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Flowable</div><div class="line">    .fromCallable &#123;&#125;</div><div class="line">    .subscribeOn()</div><div class="line">    .map(DataMapper::toData)</div><div class="line">    .subscribe()</div><div class="line"></div><div class="line"><span class="keyword">val</span> list: List&lt;String&gt; thisIsLongNamingVal</div><div class="line">    = listOf(<span class="string">""</span>)</div></pre></td></tr></table></figure>
<blockquote>
<p>注意：换行的主要目的是代码更清晰，而不一定是最小行数的代码。</p>
</blockquote>
<h4 id="继续缩进"><a href="#继续缩进" class="headerlink" title="继续缩进"></a>继续缩进</h4><p>当自动换行时，第一行后的每一行至少比第一行多缩进 4 个空格（注意：制表符不用于缩进）。当存在连续自动换行时，缩进可能会多缩进不止 4 个空格(语法元素存在多级时)。一般而言，两个连续行使用相同的缩进当且仅当它们开始于同级语法元素。</p>
<h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><p>当一个函数签名不适合一行时，将每个参数声明分解到它自己的行上。在这种格式中定义的参数应该使用继续缩进(+8)。闭括号(<code>)</code>)和返回类型被放在它们自己的行上，没有附加的缩进。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> Iterable<span class="type">&lt;T&gt;</span>.<span class="title">joinToString</span><span class="params">(</span></span></div><div class="line">        separator: <span class="type">CharSequence</span> = <span class="string">", "</span>,</div><div class="line">        prefix: <span class="type">CharSequence</span> = <span class="string">""</span>,</div><div class="line">        postfix: <span class="type">CharSequence</span> = <span class="string">""</span></div><div class="line">): String &#123;</div><div class="line">    <span class="comment">// …</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="表达式函数"><a href="#表达式函数" class="headerlink" title="表达式函数"></a>表达式函数</h4><p>当一个函数只包含一个表达式时，它可以被表示为一个表达式函数。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span>: String &#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">"Hey"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>替换为</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span>: String = <span class="string">"Hey"</span></div></pre></td></tr></table></figure>
<p>表达式函数不应该使用换行导致用两行表示。</p>
<p>如果表达式函数需要拓展则需要换行，使用正常的函数体、返回声明和正常的表达式换行规则。</p>
<h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><p>当一个属性初始化器不适用一行时，在等号（=）之后之换行并使用继续缩进规则。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">val</span> defaultCharset: Charset? =</div><div class="line">        EncodingRegistry.getInstance().getDefaultCharsetForPropertiesFiles(file)</div></pre></td></tr></table></figure>
<p>属性声明一个 getter 或者 setter 函数应该在它们所在行前加一个普通缩进（+4）。<br>使用与函数相同规则进行格式化。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> directory: File? = <span class="literal">null</span></div><div class="line">    <span class="keyword">set</span>(value) &#123;</div><div class="line">        <span class="comment">// …</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">get</span>() &#123;</div><div class="line">        <span class="keyword">return</span> value</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>对于只读属性可以使用更简洁的语法，适用于一行。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> defaultExtension: String <span class="keyword">get</span>() = <span class="string">"kt"</span></div></pre></td></tr></table></figure>
<h2 id="空白"><a href="#空白" class="headerlink" title="空白"></a>空白</h2><h4 id="垂直方向"><a href="#垂直方向" class="headerlink" title="垂直方向"></a>垂直方向</h4><p>垂直方向空白行出现原则：</p>
<ul>
<li>类的连续成员: 属性、构造函数、函数、嵌套类等等。<ul>
<li>例外：</li>
<li>两个连续属性之间的空行(在它们之间没有其他的代码)是可选的。</li>
<li>如果存在，则使用这些空白行来创建属性的逻辑分组，并将属性与它们的相关属性关联起来。</li>
</ul>
</li>
<li>在函数体内，语句的逻辑分组间使用空行。</li>
<li>类内的第一个成员变量前或最后一个成员变量后的空行是可选的(既不鼓励也不反对这样做，视个人喜好而定)。</li>
<li>根据本文档的其他部分(如“结构”一节)的要求。</li>
</ul>
<p>允许使用多个连续的空行，但不鼓励或不需要。</p>
<h4 id="水平方向"><a href="#水平方向" class="headerlink" title="水平方向"></a>水平方向</h4><p>除了语言需求和其它规则，并且除了文字，注释和 Kdoc 用到单个空格，单个 ASCII 空格也可以出现在以下几个地方：</p>
<ol>
<li>分隔任何保留字与紧随其后的左括号（<code>(</code>）（如：if、for 和 catch）。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// WRONG!</span></div><div class="line"><span class="keyword">for</span>(i <span class="keyword">in</span> <span class="number">0.</span><span class="number">.1</span>) &#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// OKay</span></div><div class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0.</span><span class="number">.1</span>) &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>分隔任何保留字与其前面的右大括号（<code>}</code>） （如：else, catch）。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// WRONG!</span></div><div class="line">&#125;<span class="keyword">else</span> &#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// OKay</span></div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>任何左大括号（<code>{</code>）前</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// WRONG!</span></div><div class="line"><span class="keyword">if</span> (list.isEmpty())&#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// OKay</span></div><div class="line"><span class="keyword">if</span> (list.isEmpty()) &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>在任何二元或三元运算符的两侧</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// WRONG!</span></div><div class="line"><span class="keyword">val</span> two = <span class="number">1</span>+<span class="number">1</span></div><div class="line"></div><div class="line"><span class="comment">// OKay</span></div><div class="line"><span class="keyword">val</span> two = <span class="number">1</span> + <span class="number">1</span></div></pre></td></tr></table></figure>
<p>同样使用于 “类似操作符” 语法：</p>
<ul>
<li>lambda 表达式（<code>-&gt;</code>）</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// WRONG!</span></div><div class="line">ints.map &#123; value-&gt;value.toString() &#125;</div><div class="line"></div><div class="line"><span class="comment">// OKay</span></div><div class="line">ints.map &#123; value -&gt; value.toString() &#125;</div></pre></td></tr></table></figure>
<p>但是不适用于：</p>
<ul>
<li>双冒号（<code>::</code>）成员引用语法</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// WRONG! </span></div><div class="line"><span class="keyword">val</span> toString = Any :: toString</div><div class="line"></div><div class="line"><span class="comment">// OKay</span></div><div class="line"><span class="keyword">val</span> toString = Any::toString</div></pre></td></tr></table></figure>
<ul>
<li>逗号(<code>.</code>)</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// WRONG! </span></div><div class="line">it . toString()</div><div class="line"></div><div class="line"><span class="comment">// OKay</span></div><div class="line">it.toString()</div></pre></td></tr></table></figure>
<ol>
<li>在一个冒号前使用（<code>:</code>）空格，仅在类使用基类或接口，或者用于 <code>where</code> <a href="https://kotlinlang.org/docs/reference/generics.html#generic-constraints" target="_blank" rel="external">泛型约束</a>时候。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// WRONG!</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>: <span class="type">Runnable</span></span></div><div class="line"></div><div class="line"><span class="comment">// Okay</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> : <span class="type">Runnable</span></span></div></pre></td></tr></table></figure>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// WRONG!</span></div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">max</span><span class="params">(a: <span class="type">T</span>, b: <span class="type">T</span>)</span></span> where T: Comparable&lt;T&gt;</div><div class="line"></div><div class="line"><span class="comment">// Okay</span></div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">max</span><span class="params">(a: <span class="type">T</span>, b: <span class="type">T</span>)</span></span> where T : Comparable&lt;T&gt;</div></pre></td></tr></table></figure>
<ol>
<li>逗号（<code>,</code>）或冒号（<code>:</code>）后。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// WRONG!</span></div><div class="line"><span class="keyword">val</span> oneAndTwo = listOf(<span class="number">1</span>,<span class="number">2</span>)</div><div class="line"></div><div class="line"><span class="comment">// Okay</span></div><div class="line"><span class="keyword">val</span> oneAndTwo = listOf(<span class="number">1</span>, <span class="number">2</span>)</div><div class="line"></div><div class="line"><span class="comment">// WRONG!</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> :<span class="type">Runnable</span></span></div><div class="line"></div><div class="line"><span class="comment">// Okay</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> : <span class="type">Runnable</span></span></div></pre></td></tr></table></figure>
<ol>
<li>如果在一条语句后做注释，则双斜杠（//）两边都要空格。这里可以允许多个空格，但没有必要。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// WRONG!</span></div><div class="line"><span class="keyword">var</span> debugging = <span class="literal">false</span><span class="comment">//disabled by default</span></div><div class="line"></div><div class="line"><span class="comment">// Okay</span></div><div class="line"><span class="keyword">var</span> debugging = <span class="literal">false</span> <span class="comment">// disabled by default</span></div></pre></td></tr></table></figure>
<blockquote>
<p>注意：这个规则并不要求或禁止一行的开关或结尾需要额外的空格，只对内部空格做要求。</p>
</blockquote>
<h2 id="特殊结构"><a href="#特殊结构" class="headerlink" title="特殊结构"></a>特殊结构</h2><h4 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h4><p>一个没有函数的枚举，且它的常量没有文档，可以随意地格式化为单行。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">Answer</span> </span>&#123; YES, NO, MAYBE &#125;</div></pre></td></tr></table></figure>
<p>当枚举中的常量被放在单独的行上时，它们之间不需要空白行，除非它们定义了一个正体。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">Answer</span> </span>&#123;</div><div class="line">    YES,</div><div class="line">    NO,</div><div class="line"></div><div class="line">    MAYBE &#123;</div><div class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span> = <span class="string">"""¯\_(ツ)_/¯"""</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>因为 enum 类是类，所以所有其他用于格式化类的规则都适用。</p>
<h4 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h4><p>在构造注释之前，成员或类型注释被放在单独的行上。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Retention(SOURCE)</span></div><div class="line"><span class="meta">@Target(FUNCTION, PROPERTY_SETTER, FIELD)</span></div><div class="line"><span class="keyword">annotation</span> <span class="class"><span class="keyword">class</span> <span class="title">Global</span></span></div></pre></td></tr></table></figure>
<p>没有参数的注释可以放在一行上。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@JvmField</span> <span class="meta">@Volatile</span></div><div class="line"><span class="keyword">var</span> disposable: Disposable? = <span class="literal">null</span></div></pre></td></tr></table></figure>
<p>当只有一个没有参数的注释时，可以放在一行上。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Volatile</span> <span class="keyword">var</span> disposable: Disposable? = <span class="literal">null</span></div><div class="line"></div><div class="line"><span class="meta">@Test</span> <span class="function"><span class="keyword">fun</span> <span class="title">selectAll</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="comment">// …</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="隐式返回-属性类型"><a href="#隐式返回-属性类型" class="headerlink" title="隐式返回/属性类型"></a>隐式返回/属性类型</h4><p>如果表达式函数体或属性初始化器是标量值，或者返回类型可以从正文中清楚地推断出来，那么就可以省略它。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span>: String = <span class="string">"Hey"</span></div><div class="line"><span class="comment">// 转换为</span></div><div class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span> = <span class="string">"Hey"</span></div></pre></td></tr></table></figure>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">val</span> ICON: Icon = IconLoader.getIcon(<span class="string">"/icons/kotlin.png"</span>)</div><div class="line"><span class="comment">// becomes</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">val</span> ICON = IconLoader.getIcon(<span class="string">"/icons/kotlin.png"</span>)</div></pre></td></tr></table></figure>
<p>在编写库时，当它是公共 <code>API</code> 的一部分时，保留显式类型声明，方便框架使用者调用。</p>
<h2 id="命名-1"><a href="#命名-1" class="headerlink" title="命名"></a>命名</h2><p>识符只能使用 ASCII 字母和数字，因此每个有效的标识符名称都能匹配正则表达式 <code>\w+</code>。</p>
<p>在 <code>Google</code> 其它编程语言风格中使用的特殊前缀或后缀，如<code>name_</code>, <code>mName</code>, <code>s_name</code> 和 <code>kName</code>，在 <code>Java</code> 编程风格中都不再使用。</p>
<p>特殊的前缀或后缀，如示例中所见的：<code>name_</code>,<code>mName</code>、<code>s_name</code> 和 <code>kName</code>，除了在备份属性（参见“<a href="https://android.github.io/kotlin-guides/style.html#backing-properties" target="_blank" rel="external">支持属性</a>”），这些都一律不使用。</p>
<h4 id="包名"><a href="#包名" class="headerlink" title="包名"></a>包名</h4><p>包名都是小写的，连续的单词简单地连接在一起(没有下划线)。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Okay</span></div><div class="line"><span class="keyword">package</span> com.example.deepspace</div><div class="line"><span class="comment">// WRONG!</span></div><div class="line"><span class="keyword">package</span> com.example.deepSpace</div><div class="line"><span class="comment">// WRONG!</span></div><div class="line"><span class="keyword">package</span> com.example.deep_space</div></pre></td></tr></table></figure>
<h4 id="类名"><a href="#类名" class="headerlink" title="类名"></a>类名</h4><p>类名是用使用驼峰命名，通常是名词或名词短语。例如：<code>Character</code> 或 <code>ImmutableList</code>。接口名也可能是名词或名词短语(例如：<code>List</code>)，但我的有时是形容词或形容词短语(例如：<code>Readable</code>)。</p>
<h4 id="函数名"><a href="#函数名" class="headerlink" title="函数名"></a>函数名</h4><p>函数名用使用驼峰命名，通常是动词或动词短语。例如：<code>sendMessage</code> 或 <code>stop</code>。下划线允许出现在测试函数名中，以分离名称的逻辑组件。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span> <span class="function"><span class="keyword">fun</span> <span class="title">pop_emptyStack</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="comment">// …</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="常量命名"><a href="#常量命名" class="headerlink" title="常量命名"></a>常量命名</h4><p>常量名命名模式为 <code>CONSTANT_CASE</code>，全部字母大写，用下划线分隔单词。那，到底什么算是一个常量？</p>
<p>常量是使用 <code>val</code> 定义并且没有 getter，其内容是不可更改的，其函数没有副作用。这包括不可变类型和不可变集合的不可变类型，如果它们标记为 const 则和标量和字符串一样。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">const <span class="keyword">val</span> NUMBER = <span class="number">5</span></div><div class="line"><span class="keyword">val</span> NAMES = listOf(<span class="string">"Alice"</span>, <span class="string">"Bob"</span>)</div><div class="line"><span class="keyword">val</span> AGES = mapOf(<span class="string">"Alice"</span> to <span class="number">35</span>, <span class="string">"Bob"</span> to <span class="number">32</span>)</div><div class="line"><span class="keyword">val</span> COMMA_JOINER = Joiner.on(<span class="string">','</span>) <span class="comment">// Joiner is immutable</span></div><div class="line"><span class="keyword">val</span> EMPTY_ARRAY = arrayOf&lt;SomeMutableType&gt;()</div></pre></td></tr></table></figure>
<p>这些名字通常是名词或名词短语。常量值只能在一个 <code>object class</code> 定义或 <code>top-level</code> 中定义。否则，在类内部定义一个常量但定义的值必须使用一个非常量名。标量值的常量必须使用 <code>const</code> 修饰符。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">const <span class="keyword">val</span> HTTP_OK = <span class="number">200</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;&#125;</div></pre></td></tr></table></figure>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">object</span> A &#123;</div><div class="line">    const <span class="keyword">val</span> HTTP_OK = <span class="number">200</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="非常量命名"><a href="#非常量命名" class="headerlink" title="非常量命名"></a>非常量命名</h4><p>非常量的名称使用骆驼拼写法。应用于实例属性、本地属性和参数名。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> variable = <span class="string">"var"</span></div><div class="line"><span class="keyword">val</span> nonConstScalar = <span class="string">"non-const"</span></div><div class="line"><span class="keyword">val</span> mutableCollection: MutableSet&lt;String&gt; = HashSet()</div><div class="line"><span class="keyword">val</span> mutableElements = listOf(mutableInstance)</div><div class="line"><span class="keyword">val</span> mutableValues = mapOf(<span class="string">"Alice"</span> to mutableInstance, <span class="string">"Bob"</span> to mutableInstance2)</div><div class="line"><span class="keyword">val</span> logger = Logger.getLogger(MyClass::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>.<span class="title">name</span>)</span></div><div class="line"><span class="keyword">val</span> nonEmptyArray = arrayOf(<span class="string">"these"</span>, <span class="string">"can"</span>, <span class="string">"change"</span>)</div></pre></td></tr></table></figure>
<p>这些名字通常是名词或名词短语。</p>
<h4 id="备份属性"><a href="#备份属性" class="headerlink" title="备份属性"></a>备份属性</h4><p>当需要一个支持属性时，它的名字应该与真正的属性完全匹配，区别在于有一个下划线。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">var</span> _table: Map&lt;String, <span class="built_in">Int</span>&gt;? = <span class="literal">null</span></div><div class="line"></div><div class="line"><span class="keyword">val</span> table: Map&lt;String, <span class="built_in">Int</span>&gt;</div><div class="line">    <span class="keyword">get</span>() &#123;</div><div class="line">        <span class="keyword">if</span> (_table == <span class="literal">null</span>) &#123;</div><div class="line">            _table = HashMap()</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> _table ?: <span class="keyword">throw</span> AssertionError()</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h4 id="类型变量名"><a href="#类型变量名" class="headerlink" title="类型变量名"></a>类型变量名</h4><p>类型变量可用以下两种风格之一进行命名：</p>
<ul>
<li>单个的大写字母，后面可以跟一个数字(如：<code>E</code>, <code>T</code>, <code>X</code>, <code>T2</code>)。</li>
<li>以类命名方式，后面加个大写的T(如：<code>RequestT</code>, <code>FooBarT</code>)。</li>
</ul>
<h4 id="驼峰式命名法-CamelCase"><a href="#驼峰式命名法-CamelCase" class="headerlink" title="驼峰式命名法(CamelCase)"></a>驼峰式命名法(CamelCase)</h4><p>驼峰式命名法分大驼峰式命名法(UpperCamelCase)和小驼峰式命名法(lowerCamelCase)。 有时，我们有不只一种合理的方式将一个英语词组转换成驼峰形式，如缩略语或不寻常的结构(例如”IPv6”或”iOS”)。Google指定了以下的转换方案。</p>
<p>名字从散文形式(prose form)开始:</p>
<ol>
<li>把短语转换为纯ASCII码，并且移除任何单引号。例如：”Müller’s algorithm”将变成”Muellers algorithm”。</li>
<li>把这个结果切分成单词，在空格或其它标点符号(通常是连字符)处分割开。<ul>
<li>推荐：如果某个单词已经有了常用的驼峰表示形式，按它的组成将它分割开(如”AdWords”将分割成”ad words”)。 需要注意的是”iOS”并不是一个真正的驼峰表示形式，因此该推荐对它并不适用。</li>
</ul>
</li>
<li>现在将所有字母都小写(包括缩写)，然后将单词的第一个字母大写：<ul>
<li>每个单词的第一个字母都大写，来得到大驼峰式命名。</li>
<li>除了第一个单词，每个单词的第一个字母都大写，来得到小驼峰式命名。</li>
</ul>
</li>
<li>最后将所有的单词连接起来得到一个标识符。</li>
</ol>
<p>示例：</p>
<table>
<thead>
<tr>
<th>Prose form</th>
<th>Correct</th>
<th>Incorrect</th>
</tr>
</thead>
<tbody>
<tr>
<td>“XML HTTP request”</td>
<td>XmlHttpRequest</td>
<td>XMLHTTPRequest</td>
</tr>
<tr>
<td>“new customer ID”</td>
<td>newCustomerId</td>
<td>newCustomerID</td>
</tr>
<tr>
<td>“inner stopwatch”</td>
<td>innerStopwatch</td>
<td>innerStopWatch</td>
</tr>
<tr>
<td>“supports IPv6 on iOS?”</td>
<td>supportsIpv6OnIos</td>
<td>supportsIPv6OnIOS</td>
</tr>
<tr>
<td>“YouTube importer”</td>
<td>YouTubeImporter or YoutubeImporter* </td>
</tr>
</tbody>
</table>
<p>加星号处表示可以，但不推荐。</p>
<blockquote>
<p>注意：在英语中，某些带有连字符的单词形式不唯一。例如：”nonempty” 和 ”non-empty” 都是正确的，因此方法名 <code>checkNonempty</code> 和<code>checkNonEmpty</code> 也都是正确的。</p>
</blockquote>
<h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><h4 id="文档格式"><a href="#文档格式" class="headerlink" title="文档格式"></a>文档格式</h4><p>KDoc 块的基本格式如下所示：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Multiple lines of KDoc text are written here,</div><div class="line"> * wrapped normally…</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">method</span><span class="params">(arg: <span class="type">String</span>)</span></span> &#123;</div><div class="line">    <span class="comment">// …</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>单行注释例子：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** An especially short bit of KDoc. */</span></div></pre></td></tr></table></figure>
<p>基本形式是可以接受的。</p>
<p>当整个 KDoc 块(包括注释标记)可以放在一行上时，可以替换单行表单。</p>
<p>请注意，只有在没有诸如 @return 这样的块标记时才会这样做。</p>
<h4 id="段落"><a href="#段落" class="headerlink" title="段落"></a>段落</h4><p>空行(即：只包含最左侧星号的行) - 出现在段落和段落标记组之前的标签。</p>
<h4 id="块标签"><a href="#块标签" class="headerlink" title="块标签"></a>块标签</h4><p>标准 KDoc 出现顺序 <code>@constructor</code>, <code>@receiver</code>, <code>@param</code>, <code>@property</code>, <code>@return</code>, <code>@throws</code>, <code>@see</code>，出现这些都不会出现在空的描述。</p>
<p>当一个块标记不适合一行时，下一行从 @ 的位置缩进 8 个空格。</p>
<h4 id="摘要片段"><a href="#摘要片段" class="headerlink" title="摘要片段"></a>摘要片段</h4><p>每个类或成员的 KDoc 以一个简短的摘要片段开始。这个片段是非常重要的，在某些情况下，它是唯一出现的文本，比如在类和方法索引中。</p>
<p>这只是一个小片段，可以是一个名词短语或动词短语，但不是一个完整的句子。它不会以 “A Foo is a…” 或 “This method returns…” 开头, 它也不会是一个完整的祈使句，如 “Save the record…”。然而，由于开头大写及被加了标点，它看起来就像是个完整的句子。</p>
<h4 id="哪里需要使用-KDoc"><a href="#哪里需要使用-KDoc" class="headerlink" title="哪里需要使用 KDoc"></a>哪里需要使用 KDoc</h4><p>至少在每个 public 类及它的每个 public 和 protected 成员变量处使用 KDoc，以下是一些例外：</p>
<ul>
<li>不言自明的方法，对于简单明显的方法如 getFoo，KDoc是可选的(即：是可以不写的)。这种情况下除了写 “Returns the foo”，确实也没有什么值得写了。</li>
<li>如果有一些相关信息是需要读者了解的，那么以上的例外不应作为忽视这些信息的理由。例如，对于方法名 getCanonicalName，就不应该忽视文档说明，因为读者很可能不知道词语 canonical name 指的是什么。</li>
<li>如果一个方法重写了超类中的方法，那么 KDoc 并非必需的。</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://android.github.io/kotlin-guides/style.html#braces" target="_blank" rel="external">Google Kotlin CodeStyle</a></li>
<li><a href="http://hax.iteye.com/blog/160003" target="_blank" rel="external">谈 literal 译名之选择</a></li>
<li><a href="https://blog.kotlin-academy.com/kotlin-programmer-dictionary-statement-vs-expression-e6743ba1aaa0" target="_blank" rel="external">Statement vs Expression</a></li>
</ul>
</div></article></div></main><footer><div class="paginator"><a href="/2017/10/14/solid-spp/" class="next">下一篇</a></div><div class="copyright"><p>© 2015 - 2017 <a href="http://yoursite.com">Averson</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>
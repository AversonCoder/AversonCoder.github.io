<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Kotlin 中 Lambda 的使用 · Averson</title><meta name="description" content="Kotlin 中 Lambda 的使用 - Averson"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="Averson"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/aversoncoder" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">Kotlin 中 Lambda 的使用</h1><div class="post-info">2017年7月10日</div><div class="post-content"><p><code>Kotlin Lambda</code> 记录</p>
<a id="more"></a>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul>
<li><code>Java</code> 中 <code>Lambda</code> 的简介</li>
<li><code>Kotlin</code> 中 <code>Lambda</code> 表达式介绍</li>
</ul>
<h2 id="Java-中-Lambda-的简介"><a href="#Java-中-Lambda-的简介" class="headerlink" title="Java 中 Lambda 的简介"></a>Java 中 Lambda 的简介</h2><p><code>Lambda</code> 表达式是在 <code>Java 8</code> 开始引入一项重大的改变。简而言之，<code>Lambda</code> 表达式是一小段的代码块用来简化代码和更方便面向函数式编程。</p>
<p><strong>Lambda 作为方法参数的使用</strong></p>
<p>编程中，传递和存储这些行为代码（表达式）是常见的。比方说：当某个事件触发，你需要去处理或者应用某个操作作用于数据结构的所有元素身上。</p>
<p><strong>在 <code>Java 8</code> 以下</strong>，我们通常借助匿名内部类实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// run a task</span></div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>那么对于函数式编程来说，函数作为一等公民，我们可以视为一个值。函数可以作为值进行传递，而不是声明一个类然后将该类传递给方法。让函数作为值传递，你也可以不需要声明一个函数，相反，你可以直接传递一个代码块作为函数参数传递。</p>
<p>上述概念用数学表达式来说：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">f(x) = x + 2</div><div class="line">y(x) = f(x) + 3</div></pre></td></tr></table></figure>
<p>这里 <code>f(x)</code> 完全可以视为值（3）的另一种表达。传递给 <code>y(x)</code> 作为运算的一部分处理。</p>
<p>对应到编程上，<code>f(x)</code> 作为一个函数传递给 <code>y(x)</code> 动态影响 <code>y(x)</code> 最终结果的形成。有助于函数更灵活和方便拓展。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> Runnable() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// run a task</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>在 <code>Java 8</code> 中</strong>我们可以替换为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// f(x) = x + 2</span></div><div class="line">Runnable task = () -&gt; &#123; <span class="comment">//run a task &#125;</span></div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// y(x) = f(x) + 3</span></div><div class="line"><span class="keyword">new</span> Thread(task)</div><div class="line"></div><div class="line"><span class="comment">// 也可以不声明函数仅传递代码块</span></div><div class="line"><span class="keyword">new</span> Thread( () -&gt; &#123; <span class="comment">// run a task &#125; )</span></div></pre></td></tr></table></figure>
<p>其中 <code>() -&gt; { // run a task }</code> 便是 <code>Lambda</code> 表达式，语法规则如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">函数 = ( 参数 ) -&gt; &#123; 运算逻辑 &#125;</div></pre></td></tr></table></figure>
<p>有一点需要注意，<code>Lamdba</code> 更偏向于我们所认知的数学函数。即一个函数只有一个函数逻辑，同样的值产生同样的结果。</p>
<p>即：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">f(x) = x + 1</div><div class="line">x = 1</div><div class="line">f(1) = 1 + 1 = 2</div></pre></td></tr></table></figure>
<p>不存在说：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">f(x) = x + 1</div><div class="line">f(x) = x + 2 </div><div class="line">x = 1</div><div class="line">f(1) = 1 or 3</div></pre></td></tr></table></figure>
<p>因此这也对应 <code>Java 8</code> 中函数式接口注解（<code>@FunctionalInterface</code>）的概念，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@FunctionalInterface</div><div class="line">public interface Runnable &#123;</div><div class="line">    public abstract void run();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对应数学可以理解成 <code>f(x) = x</code>，其中 <code>x = 0</code>。</p>
<p>更多函数式的接口可以看 <code>java.util.function</code> 包下的定义。</p>
<h2 id="Kotlin-中-Lambda-表达式介绍"><a href="#Kotlin-中-Lambda-表达式介绍" class="headerlink" title="Kotlin 中 Lambda 表达式介绍"></a>Kotlin 中 Lambda 表达式介绍</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123; 参数, 参数 -&gt; 实现逻辑 &#125;</div></pre></td></tr></table></figure>
<p>创建一个 <code>Lambda</code> 表达式：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> sum = &#123; num1, num2 -&gt; num1 + num2 &#125;</div><div class="line"><span class="keyword">val</span> actual = sum(<span class="number">1</span>, <span class="number">2</span>)</div><div class="line"><span class="keyword">val</span> expected = <span class="number">3</span></div><div class="line">Assert.assertEquals(expected, actual)</div></pre></td></tr></table></figure>
<p>直接执行一个 <code>Lambda</code></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123; println(<span class="string">"Averson"</span>) &#125;()</div></pre></td></tr></table></figure>
<p>上述代码没有什么可读性，可以使用 <code>kotlin</code> 提供的 run 执行一个<code>lambda</code> 更具备可读性。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">run &#123; println(<span class="string">"Averson"</span>) &#125;</div></pre></td></tr></table></figure>
<p>完整语法：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">IntStream.range(<span class="number">1</span>, <span class="number">10</span>)</div><div class="line">    .forEach(&#123; number: <span class="built_in">Int</span> -&gt;</div><div class="line">        println(number)</div><div class="line">    &#125;)</div></pre></td></tr></table></figure>
<p>虽然较之于匿名内部类有了很大的改变，但是就看上去还有几点显得啰嗦：</p>
<ul>
<li>太多标点符号，阅读上不痛不痒的。</li>
<li>参数类型能从上下文中推断出来，因此可以省略。</li>
<li>该代码没必要在 <code>Lambda</code> 指定一个参数名（<code>it</code>）。</li>
</ul>
<p>在 <code>Kotlin</code> 中，当 <code>Lambda</code> 表达式是函数最后一个参数时，<code>Lambda</code> 可以移出函数的圆括号外。上面的代码中只有一个参数，所以我们可以把 <code>Lambda</code> 移到函数的圆括号后面。</p>
<p>综合上面说的我们可以简化一下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">IntStream.range(<span class="number">1</span>, <span class="number">10</span>)</div><div class="line">    .forEach() &#123;</div><div class="line">        println(it)</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>再者当函数只有一个参数的时候 “()” 也可以直接省略了，所以最后的结果是：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">IntStream.range(<span class="number">1</span>, <span class="number">10</span>)</div><div class="line">    .forEach &#123;</div><div class="line">        println(it)</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>良好的编程风格包括 <strong>“编写更少的重复代码”</strong> 这一原则。在一些集合操作中，我们并不能完全符合这一原则。比如：常见的数据收集，我们不断重复进行 <code>for</code> 循环这些繁琐的代码。因此 <code>Kotlin</code> 提供良好的 <code>API</code> 来让我们减少这些繁琐的工作（<code>Java 8 Stream</code> 也可以做这事，主题原因不多加赘述增加篇幅）。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Feed</span></span>(<span class="keyword">val</span> content: String, <span class="keyword">val</span> tag: String)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">listHotFeeds</span><span class="params">(feeds: <span class="type">List</span>&lt;<span class="type">Feed</span>&gt;)</span></span>: List&lt;Feed&gt; &#123;</div><div class="line">    <span class="keyword">val</span> hotFeeds = ArrayList&lt;Feed&gt;()</div><div class="line">    <span class="keyword">for</span> (feed <span class="keyword">in</span> feeds) &#123;</div><div class="line">        <span class="keyword">if</span> (feed.tag == <span class="string">"Hot"</span>) &#123;</div><div class="line">            hotFeeds.add(feed)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> hotFeeds</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对于这段代码曾几何时我们更想如果可以写成 <code>资讯.是热门资讯.收集</code> 这样该多好，因为这样的代码看起来更像一种自然的语言描述。当然这在 <code>Kotlin</code> 中是很容易实现的。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">listHotFeeds</span><span class="params">(feeds: <span class="type">List</span>&lt;<span class="type">Feed</span>&gt;)</span></span>: List&lt;Feed&gt; &#123;</div><div class="line">    <span class="keyword">return</span> feeds.filter &#123; feed -&gt; feed.tag == <span class="string">"Hot"</span> &#125;.toList()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>再如我们想筛选出内容最长的资讯。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">findMaxContentFeed</span><span class="params">(feeds: <span class="type">List</span>&lt;<span class="type">Feed</span>&gt;)</span></span>: Feed? &#123;</div><div class="line">    <span class="keyword">var</span> maxContentFeed: Feed? = <span class="literal">null</span></div><div class="line">    <span class="keyword">var</span> maxLength = <span class="number">0</span></div><div class="line">    <span class="keyword">for</span> (feed <span class="keyword">in</span> feeds) &#123;</div><div class="line">        <span class="keyword">val</span> length = feed.content.length</div><div class="line">        <span class="keyword">if</span> (length &gt; maxLength) &#123;</div><div class="line">            maxLength = length</div><div class="line">            maxContentFeed = feed</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> maxContentFeed</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然而对于问题的本质思考我们第一时间应该想到的自然语言描述是 <code>资讯.根据最长内容得出结果</code>，显然这在 <code>Kotlin</code> 的标准库中也提供了。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">findMaxContentFeed</span><span class="params">(feeds: <span class="type">List</span>&lt;<span class="type">Feed</span>&gt;)</span></span>: Feed? &#123;</div><div class="line">    <span class="keyword">return</span> feeds.maxBy &#123; it.content.length &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>简化的目的是为了可读性，尽管 <code>Lambda</code> 可以简化代码，但有的时候 <code>Lambda</code> 并不能增进可读性。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> upperCaseLatters = IntStream.range(<span class="number">65</span>, <span class="number">90</span>)</div><div class="line">        .mapToObj &#123; it.toChar() &#125;</div><div class="line">        .map &#123; Character.toString(it) &#125;</div><div class="line">        .toList()</div><div class="line"><span class="keyword">val</span> result = upperCaseLatters.joinToString(<span class="string">"-"</span>) &#123; it &#125;</div><div class="line">println(result)</div></pre></td></tr></table></figure>
<p>显然上述的 <code>joinToString(&quot;-&quot;) { it }</code> 并不能有助于阅读。</p>
<p>所以我们应该写成：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">upperCaseLetter.joinToString(separator = <span class="string">"-"</span>, transform = &#123; it &#125;)</div></pre></td></tr></table></figure>
<p>修改后我们可以很明确的知道了 “-“ 是分割符，而内容不需要转换操作，所以直接返回内容本身。</p>
<p>简而言之，具体问题具体分析，不管代码用什么方式写，只要保证一眼看上去清晰明了即可。</p>
<p>上述讲了很多都是 <code>Lambda</code> 内部的操作，现在看一下<strong>Lambda 访问局部变量</strong>。</p>
<p>在 Java 中当方法体内声明一个匿名内部类，你能在匿名内部类中引用方法参数和方法内的变量。而 <code>Lambda</code> 也能做到这些事。</p>
<p>比如我们为 Collection<string> 添加一个拓展函数用作 debug 用途：</string></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> Collection<span class="type">&lt;String&gt;</span>.<span class="title">log</span><span class="params">(tag: <span class="type">String</span>)</span></span> &#123;</div><div class="line">    <span class="comment">// 在 Lambda 中访问参数 tag</span></div><div class="line">    forEach &#123; println(<span class="string">"<span class="variable">$tag</span>: <span class="variable">$it</span>"</span>) &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>Java</code> 和 <code>Kotlin</code> 的一个重要区别在于：在 <code>Kotlin</code> 的 <code>Lambda</code> 中不局限于访问 <code>final</code> 变量，你还可以修改变量值。</p>
<p>比方说在 <code>Java</code> 中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> <span class="keyword">int</span> temp = <span class="number">1</span>;</div><div class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</div><div class="line">    println(temp); <span class="comment">// access temp must is final</span></div><div class="line">    temp = <span class="number">2</span>; <span class="comment">// not allow</span></div><div class="line">&#125;).start();</div></pre></td></tr></table></figure>
<p>折衷的处理办法是:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> <span class="keyword">int</span>[] temp = &#123; <span class="number">1</span> &#125;;</div><div class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</div><div class="line">    temp[<span class="number">0</span>] = <span class="number">2</span>;</div><div class="line">&#125;).start();</div></pre></td></tr></table></figure>
<p>而 <code>Kotlin</code> 中你可以访问变量和修改变量（本质和折衷的方法异曲同工）：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> temp = <span class="number">1</span></div><div class="line">Thread &#123;</div><div class="line">    println(temp)</div><div class="line">    temp = <span class="number">2</span></div><div class="line">    println(temp)</div><div class="line">&#125;.start()</div></pre></td></tr></table></figure>
<p>因为当你访问一个 <code>val</code> 变量的时候和 <code>Java</code> 的没区别，但是对于非 <code>final</code> 的变量来说又是为什么它不用 <code>final</code> 而且还可以修改呢？本质上其实是将值包裹进一个对象里，在 <code>Lambda</code> 中操作这个对象，对象是不可变的，但是对象内部的值是可变的。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> IntRef temp = new IntRef();</div><div class="line">temp.element = <span class="number">1</span>;</div><div class="line">new Thread(() -&gt; &#123;</div><div class="line">    int var1 = temp.element;</div><div class="line">    System.<span class="keyword">out</span>.println(var1);</div><div class="line">    temp.element = <span class="number">2</span>;</div><div class="line">    var1 = temp.element</div><div class="line">    System.<span class="keyword">out</span>.println(var1);</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>需要注意一点：如果 <code>Lambda</code> 作为事件处理逻辑，或者异步执行。那么只有在执行 <code>Lambda</code> 的时候变量才会发声修改。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">countButtonClicks</span><span class="params">(button: <span class="type">Button</span>)</span></span>: <span class="built_in">Int</span> &#123;</div><div class="line">    <span class="keyword">var</span> clicks = <span class="number">0</span></div><div class="line">    button.setOnclick &#123;</div><div class="line">        clicks++;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> clicks</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上述函数永远返回 0。尽管按钮点击修改了 <code>clicks</code>，但是你并观察不到变化，因为 <code>onClick</code> 的处理在返回 <code>clicks</code> 之后。一个正确的处理方式应该是让 <code>clicks</code> 不作为局部变量而是作为一个类的属性进行存储。</p>
<p><strong>接下来看一下成员引用</strong>，设想一下，如果你需要作为参数传递的代码块被定义为函数。那该怎么处理？</p>
<p>答案是：你可以传递一个调用该函数的 <code>Lambda</code>（ { func() } ），但是这样做是多余的。在 <code>Kotlin</code> 中和 <code>Java 8</code> 一样，如果你需要把函数转化为一个值传递你可以使用 <code>::</code> 来表示。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 语法</span></div><div class="line">Class::member</div><div class="line"><span class="comment">// 使用</span></div><div class="line"><span class="keyword">val</span> getAppleWeight = Apple::weight</div><div class="line">apples.maxBy(getAppleWeight)</div></pre></td></tr></table></figure>
<p><code>Apple::weight</code> 相当于：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> getAppleWeight = &#123; apple:Apple -&gt; apple.weight &#125;</div></pre></td></tr></table></figure>
<p>函数也是同理，也可以直接省去函数赋值的步骤。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">runTask</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="keyword">val</span> welcome = ::welcome</div><div class="line">    Thread(welcome).start()</div><div class="line">    <span class="comment">// or</span></div><div class="line">    Thread(::welcome).start()</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">welcome</span><span class="params">()</span></span> &#123;</div><div class="line">    println(<span class="string">"welcome"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>构造函数：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Apple</span></span>(<span class="keyword">val</span> weight: <span class="built_in">Int</span>, <span class="keyword">val</span> color: String)</div><div class="line"></div><div class="line"><span class="keyword">val</span> newApple = ::Apple</div><div class="line"><span class="keyword">val</span> apple = newApple(<span class="number">10</span>, <span class="string">"Green"</span>)</div><div class="line">println(apple)</div></pre></td></tr></table></figure>
<p>拓展函数：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> Apple.<span class="title">isHealth</span><span class="params">()</span></span> = weight &gt; <span class="number">20</span></div><div class="line"><span class="keyword">val</span> predicate = Apple::isHealth</div></pre></td></tr></table></figure>
<blockquote>
<p>在 Kotlin 1.1 之前当你引用方法和属性的时候总需要传入实例，1.1 之后已经不需要了</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 1.0</span></div><div class="line"><span class="keyword">val</span> apple = Apple(<span class="number">10</span>, <span class="string">"Green"</span>)</div><div class="line"><span class="keyword">val</span> getAppleWeight = Apple::weight</div><div class="line"><span class="keyword">val</span> weight = getAppleWeight(apple)</div><div class="line"><span class="comment">// 1.1</span></div><div class="line"><span class="keyword">val</span> getAppleWeight = apple::weight</div><div class="line"><span class="keyword">val</span> weight = getAppleWeight()</div></pre></td></tr></table></figure>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 前者类似于</span></div><div class="line">int getWeight(Apple apple) &#123;</div><div class="line">    <span class="keyword">return</span> apple.getWeight()</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 后者</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wrapper</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> apple: Apple) &#123;</div><div class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getWeight</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="keyword">this</span>.apple.weight</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>仅需记住一点，使用 <code>::</code> 语法时保证入参和返回值一致即可。 </p>
<p>最后，在 <code>Kotlin</code> 中你可以传递 <code>Lambda</code> 给参数为函数式接口的 <code>Java</code> 方法。编译器会自动转换为对应的接口实例。比如：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> cacheExecutor = Executors.newCachedThreadPool()</div><div class="line">cacheExecutor.submit(&#123; println(<span class="string">"Hello"</span>) &#125;)</div></pre></td></tr></table></figure>
<p>传递 <code>Lambda</code> 给 <code>submit</code> 方法过程中我们创建了一个实现了 <code>Runnable</code> 接口的匿名内部类并且编译器将把 <code>lambda</code> 中的逻辑作为<strong>函数式接口</strong>中唯一方法的主体。即 <code>{ println(&quot;Hello&quot;) }</code> 看作 <code>Java</code> 中的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">    println(<span class="string">"Hello"</span>);</div><div class="line">&#125;</div><div class="line">`</div></pre></td></tr></table></figure>
<p>当然也可以明确指定匿名内部类</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">cacheExecutor.submit(<span class="keyword">object</span> : Runnable &#123;</div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span> &#123;</div><div class="line">        println(<span class="string">"Hello"</span>)</div><div class="line">    &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>那么 <code>lambda</code> 和 <code>object class</code> 的区别在哪里？</p>
<p>区别在于 <code>object class</code> 每次都会创建一个匿名类实例，而对于 <code>lambda</code>，如果没有访问外部变量，那么它对应的匿名类实例是可以重用的。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> task = &#123; println(<span class="string">"execute logic"</span>) &#125;</div><div class="line"></div><div class="line"><span class="keyword">val</span> cacheExecutor = Executors.newCachedThreadPool()</div><div class="line">cacheExecutor.submit(task)</div><div class="line"></div><div class="line"><span class="keyword">val</span> singleExecutor = Executors.newSingleThreadExecutor()</div><div class="line">singleExecutor.submit(task)</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">runTask</span><span class="params">(tag: <span class="type">String</span>)</span></span> &#123;</div><div class="line">    cacheExecutor.submit(&#123; println(<span class="string">"run <span class="variable">$tag</span> task"</span>) &#125;)</div><div class="line">    <span class="comment">// or</span></div><div class="line">    cacheExecutor.submit(<span class="keyword">object</span> : Runnable &#123;</div><div class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span> &#123;</div><div class="line">            println(<span class="string">"run <span class="variable">$tag</span> task"</span>)</div><div class="line">        &#125;</div><div class="line">    &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure></div></article></div></main><footer><div class="paginator"><a href="/2017/07/12/kotlin-collections/" class="prev">上一篇</a><a href="/2017/07/08/arch-lifecycle/" class="next">下一篇</a></div><div class="copyright"><p>© 2015 - 2017 <a href="http://yoursite.com">Averson</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>